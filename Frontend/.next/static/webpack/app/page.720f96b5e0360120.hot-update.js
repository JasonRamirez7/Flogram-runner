"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/@munezero/floparser/index.js":
/*!******************************************!*\
  !*** ./app/@munezero/floparser/index.js ***!
  \******************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Tokenizer_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Tokenizer/index.mjs */ \"(app-pages-browser)/./app/@munezero/floparser/Tokenizer/index.mjs\");\n/* harmony import */ var _SimpleParser_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SimpleParser/index.mjs */ \"(app-pages-browser)/./app/@munezero/floparser/SimpleParser/index.mjs\");\n/* harmony import */ var _Compilers_SimplerWASM_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Compilers/SimplerWASM/index.mjs */ \"(app-pages-browser)/./app/@munezero/floparser/Compilers/SimplerWASM/index.mjs\");\n/* harmony import */ var _Compilers_MemoryManager_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Compilers/MemoryManager/index.mjs */ \"(app-pages-browser)/./app/@munezero/floparser/Compilers/MemoryManager/index.mjs\");\n/* harmony import */ var _Tests_Shared_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Tests/Shared/index.mjs */ \"(app-pages-browser)/./app/@munezero/floparser/Tests/Shared/index.mjs\");\n\n\n\n\n\nconst execute = (glue, module)=>new Promise(async (resolve, reject)=>{\n        let key;\n        const outputs = [];\n        for (const [iKey, value] of Object.entries(glue.procedures)){\n            const { name, path } = value;\n            if (name === \"main\" && path === \"Module\") {\n                key = iKey;\n                break;\n            }\n        }\n        if (key) {\n            try {\n                const memory = new WebAssembly.Memory({\n                    initial: 128\n                });\n                const state = (0,_Compilers_MemoryManager_index_mjs__WEBPACK_IMPORTED_MODULE_3__.createMemoryManager)(memory);\n                const drawer = (0,_Compilers_MemoryManager_index_mjs__WEBPACK_IMPORTED_MODULE_3__.createDrawer)(memory, outputs);\n                const dates = (0,_Compilers_MemoryManager_index_mjs__WEBPACK_IMPORTED_MODULE_3__.createDate)();\n                const descriptionImports = Object.freeze({\n                    imports: {}\n                });\n                const memoryImport = \"memory\";\n                Object.keys(glue.imports).forEach((importKey)=>{\n                    if (state[importKey]) {\n                        descriptionImports.imports[importKey] = state[importKey];\n                    }\n                    if (drawer[importKey]) {\n                        descriptionImports.imports[importKey] = drawer[importKey];\n                    }\n                    if (dates[importKey]) {\n                        descriptionImports.imports[importKey] = dates[importKey];\n                    }\n                    if (importKey === memoryImport) {\n                        descriptionImports.imports[importKey] = memory;\n                    }\n                });\n                const moduleCompiled = await WebAssembly.compile(module);\n                const moduleInstance = await WebAssembly.instantiate(moduleCompiled, descriptionImports);\n                const procedure = moduleInstance.exports[key];\n                if (procedure) {\n                    let value = procedure();\n                    resolve(outputs);\n                }\n            } catch (e) {\n                reject([\n                    {\n                        message: e.message,\n                        type: 100,\n                        position: 0,\n                        length: 0\n                    }\n                ]);\n            }\n        } else {\n            reject([\n                {\n                    message: \"Error: Missing main function. Every Flogram program must include an entry point defined as the main function.\",\n                    type: 101,\n                    position: 0,\n                    length: 0\n                }\n            ]);\n        }\n    });\nconst run = (value)=>new Promise(async (resolve, reject)=>{\n        const failures = [];\n        let representation = null;\n        const ENCODER = new TextEncoder();\n        const tokenizer = new _Tokenizer_index_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n        const parser = _SimpleParser_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].create({\n            path: \"Module\",\n            imports: _Tests_Shared_index_mjs__WEBPACK_IMPORTED_MODULE_4__.SIMPLE_IMPORTS\n        });\n        parser.on(_SimpleParser_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].EVENT_FAIL, (failure)=>{\n            failures = [\n                ...failures,\n                failure\n            ];\n            representation = null;\n        });\n        parser.on(_SimpleParser_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].EVENT_DONE, (data)=>{\n            representation = data;\n        });\n        tokenizer.on(\"token\", (position, array, index, length)=>{\n            parser.feed(position, array, index, length);\n        });\n        tokenizer.feed(ENCODER.encode(value));\n        tokenizer.done();\n        parser.done();\n        if (representation) {\n            const compilerOptions = Object.freeze({\n                memory: true\n            });\n            const [glue, module] = _Compilers_SimplerWASM_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].compile(representation, compilerOptions);\n            execute(glue, module).then((res)=>{\n                resolve(res);\n            }).catch((err)=>{\n                reject(err);\n            });\n        } else {\n            //couldn't parse, return parsing errors\n            reject(failures);\n        }\n    });\nconst module = {\n    run,\n    Parser: _SimpleParser_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n    Tokenizer: _Tokenizer_index_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n    Compiler: _Compilers_SimplerWASM_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n    MemoryManager: _Compilers_MemoryManager_index_mjs__WEBPACK_IMPORTED_MODULE_3__.createMemoryManager,\n    Draw: _Compilers_MemoryManager_index_mjs__WEBPACK_IMPORTED_MODULE_3__.createDrawer,\n    Dates: _Compilers_MemoryManager_index_mjs__WEBPACK_IMPORTED_MODULE_3__.createDate,\n    SIMPLE_IMPORTS: _Tests_Shared_index_mjs__WEBPACK_IMPORTED_MODULE_4__.SIMPLE_IMPORTS\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (module);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9AbXVuZXplcm8vZmxvcGFyc2VyL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE4QztBQUNBO0FBQ1c7QUFLWjtBQUNhO0FBRTFELE1BQU1VLFVBQVUsQ0FBQ0MsTUFBTUMsU0FDckIsSUFBSUMsUUFBUSxPQUFPQyxTQUFTQztRQUMxQixJQUFJQztRQUVKLE1BQU1DLFVBQVUsRUFBRTtRQUVsQixLQUFLLE1BQU0sQ0FBQ0MsTUFBTUMsTUFBTSxJQUFJQyxPQUFPQyxPQUFPLENBQUNWLEtBQUtXLFVBQVUsRUFBRztZQUMzRCxNQUFNLEVBQUVDLElBQUksRUFBRUMsSUFBSSxFQUFFLEdBQUdMO1lBQ3ZCLElBQUlJLFNBQVMsVUFBVUMsU0FBUyxVQUFVO2dCQUN4Q1IsTUFBTUU7Z0JBQ047WUFDRjtRQUNGO1FBRUEsSUFBSUYsS0FBSztZQUNQLElBQUk7Z0JBQ0YsTUFBTVMsU0FBUyxJQUFJQyxZQUFZQyxNQUFNLENBQUM7b0JBQ3BDQyxTQUFTO2dCQUNYO2dCQUVBLE1BQU1DLFFBQVF6Qix1RkFBYUEsQ0FBQ3FCO2dCQUM1QixNQUFNSyxTQUFTeEIsZ0ZBQUlBLENBQUNtQixRQUFRUjtnQkFDNUIsTUFBTWMsUUFBUXZCLDhFQUFLQTtnQkFFbkIsTUFBTXdCLHFCQUFxQlosT0FBT2EsTUFBTSxDQUFDO29CQUN2Q0MsU0FBUyxDQUFDO2dCQUNaO2dCQUVBLE1BQU1DLGVBQWU7Z0JBRXJCZixPQUFPZ0IsSUFBSSxDQUFDekIsS0FBS3VCLE9BQU8sRUFBRUcsT0FBTyxDQUFDLENBQUNDO29CQUNqQyxJQUFJVCxLQUFLLENBQUNTLFVBQVUsRUFBRTt3QkFDcEJOLG1CQUFtQkUsT0FBTyxDQUFDSSxVQUFVLEdBQUdULEtBQUssQ0FBQ1MsVUFBVTtvQkFDMUQ7b0JBQ0EsSUFBSVIsTUFBTSxDQUFDUSxVQUFVLEVBQUU7d0JBQ3JCTixtQkFBbUJFLE9BQU8sQ0FBQ0ksVUFBVSxHQUFHUixNQUFNLENBQUNRLFVBQVU7b0JBQzNEO29CQUNBLElBQUlQLEtBQUssQ0FBQ08sVUFBVSxFQUFFO3dCQUNwQk4sbUJBQW1CRSxPQUFPLENBQUNJLFVBQVUsR0FBR1AsS0FBSyxDQUFDTyxVQUFVO29CQUMxRDtvQkFDQSxJQUFJQSxjQUFjSCxjQUFjO3dCQUM5QkgsbUJBQW1CRSxPQUFPLENBQUNJLFVBQVUsR0FBR2I7b0JBQzFDO2dCQUNGO2dCQUVBLE1BQU1jLGlCQUFpQixNQUFNYixZQUFZYyxPQUFPLENBQUM1QjtnQkFDakQsTUFBTTZCLGlCQUFpQixNQUFNZixZQUFZZ0IsV0FBVyxDQUNsREgsZ0JBQ0FQO2dCQUdGLE1BQU1XLFlBQVlGLGVBQWVHLE9BQU8sQ0FBQzVCLElBQUk7Z0JBRTdDLElBQUkyQixXQUFXO29CQUNiLElBQUl4QixRQUFRd0I7b0JBRVo3QixRQUFRRztnQkFDVjtZQUNGLEVBQUUsT0FBTzRCLEdBQUc7Z0JBQ1Y5QixPQUFPO29CQUNMO3dCQUNFK0IsU0FBU0QsRUFBRUMsT0FBTzt3QkFDbEJDLE1BQU07d0JBQ05DLFVBQVU7d0JBQ1ZDLFFBQVE7b0JBQ1Y7aUJBQ0Q7WUFDSDtRQUNGLE9BQU87WUFDTGxDLE9BQU87Z0JBQ0w7b0JBQ0UrQixTQUNFO29CQUNGQyxNQUFNO29CQUNOQyxVQUFVO29CQUNWQyxRQUFRO2dCQUNWO2FBQ0Q7UUFDSDtJQUNGO0FBRUYsTUFBTUMsTUFBTSxDQUFDL0IsUUFDWCxJQUFJTixRQUFRLE9BQU9DLFNBQVNDO1FBQzFCLE1BQU1vQyxXQUFXLEVBQUU7UUFDbkIsSUFBSUMsaUJBQWlCO1FBRXJCLE1BQU1DLFVBQVUsSUFBSUM7UUFFcEIsTUFBTUMsWUFBWSxJQUFJdkQsNERBQVNBO1FBRS9CLE1BQU13RCxTQUFTdkQsK0RBQU1BLENBQUN3RCxNQUFNLENBQUM7WUFDM0JqQyxNQUFNO1lBQ05VLFNBQVN6QixtRUFBY0E7UUFDekI7UUFFQStDLE9BQU9FLEVBQUUsQ0FBQ3pELCtEQUFNQSxDQUFDMEQsVUFBVSxFQUFFLENBQUNDO1lBQzVCVCxXQUFXO21CQUFJQTtnQkFBVVM7YUFBUTtZQUNqQ1IsaUJBQWlCO1FBQ25CO1FBRUFJLE9BQU9FLEVBQUUsQ0FBQ3pELCtEQUFNQSxDQUFDNEQsVUFBVSxFQUFFLENBQUNDO1lBQzVCVixpQkFBaUJVO1FBQ25CO1FBRUFQLFVBQVVHLEVBQUUsQ0FBQyxTQUFTLENBQUNWLFVBQVVlLE9BQU9DLE9BQU9mO1lBQzdDTyxPQUFPUyxJQUFJLENBQUNqQixVQUFVZSxPQUFPQyxPQUFPZjtRQUN0QztRQUVBTSxVQUFVVSxJQUFJLENBQUNaLFFBQVFhLE1BQU0sQ0FBQy9DO1FBRTlCb0MsVUFBVVksSUFBSTtRQUVkWCxPQUFPVyxJQUFJO1FBRVgsSUFBSWYsZ0JBQWdCO1lBQ2xCLE1BQU1nQixrQkFBa0JoRCxPQUFPYSxNQUFNLENBQUM7Z0JBQ3BDUixRQUFRO1lBQ1Y7WUFFQSxNQUFNLENBQUNkLE1BQU1DLE9BQU8sR0FBR1Ysd0VBQVFBLENBQUNzQyxPQUFPLENBQUNZLGdCQUFnQmdCO1lBRXhEMUQsUUFBUUMsTUFBTUMsUUFDWHlELElBQUksQ0FBQyxDQUFDQztnQkFDTHhELFFBQVF3RDtZQUNWLEdBQ0NDLEtBQUssQ0FBQyxDQUFDQztnQkFDTnpELE9BQU95RDtZQUNUO1FBQ0osT0FBTztZQUNMLHVDQUF1QztZQUN2Q3pELE9BQU9vQztRQUNUO0lBQ0Y7QUFFRixNQUFNdkMsU0FBUztJQUNic0M7SUFDQWpELE1BQU1BLGlFQUFBQTtJQUNORCxTQUFTQSw4REFBQUE7SUFDVEUsUUFBUUEsMEVBQUFBO0lBQ1JFLGFBQWFBLHFGQUFBQTtJQUNiRSxJQUFJQSw4RUFBQUE7SUFDSkUsS0FBS0EsNEVBQUFBO0lBQ0xDLGNBQWNBLHFFQUFBQTtBQUNoQjtBQUVBLGlFQUFlRyxNQUFNQSxFQUFDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEpBU09OXFxEZXNrdG9wXFxOZXcgZm9sZGVyXFxhcHBcXEBtdW5lemVyb1xcZmxvcGFyc2VyXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVG9rZW5pemVyIGZyb20gXCIuL1Rva2VuaXplci9pbmRleC5tanNcIjtcbmltcG9ydCBQYXJzZXIgZnJvbSBcIi4vU2ltcGxlUGFyc2VyL2luZGV4Lm1qc1wiO1xuaW1wb3J0IENvbXBpbGVyIGZyb20gXCIuL0NvbXBpbGVycy9TaW1wbGVyV0FTTS9pbmRleC5tanNcIjtcbmltcG9ydCB7XG4gIGNyZWF0ZU1lbW9yeU1hbmFnZXIgYXMgTWVtb3J5TWFuYWdlcixcbiAgY3JlYXRlRHJhd2VyIGFzIERyYXcsXG4gIGNyZWF0ZURhdGUgYXMgRGF0ZXMsXG59IGZyb20gXCIuL0NvbXBpbGVycy9NZW1vcnlNYW5hZ2VyL2luZGV4Lm1qc1wiO1xuaW1wb3J0IHsgU0lNUExFX0lNUE9SVFMgfSBmcm9tIFwiLi9UZXN0cy9TaGFyZWQvaW5kZXgubWpzXCI7XG5cbmNvbnN0IGV4ZWN1dGUgPSAoZ2x1ZSwgbW9kdWxlKSA9PlxuICBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgbGV0IGtleTtcblxuICAgIGNvbnN0IG91dHB1dHMgPSBbXTtcblxuICAgIGZvciAoY29uc3QgW2lLZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhnbHVlLnByb2NlZHVyZXMpKSB7XG4gICAgICBjb25zdCB7IG5hbWUsIHBhdGggfSA9IHZhbHVlO1xuICAgICAgaWYgKG5hbWUgPT09IFwibWFpblwiICYmIHBhdGggPT09IFwiTW9kdWxlXCIpIHtcbiAgICAgICAga2V5ID0gaUtleTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbWVtb3J5ID0gbmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7XG4gICAgICAgICAgaW5pdGlhbDogMTI4LFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBzdGF0ZSA9IE1lbW9yeU1hbmFnZXIobWVtb3J5KTtcbiAgICAgICAgY29uc3QgZHJhd2VyID0gRHJhdyhtZW1vcnksIG91dHB1dHMpO1xuICAgICAgICBjb25zdCBkYXRlcyA9IERhdGVzKCk7XG5cbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb25JbXBvcnRzID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgaW1wb3J0czoge30sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IG1lbW9yeUltcG9ydCA9IFwibWVtb3J5XCI7XG5cbiAgICAgICAgT2JqZWN0LmtleXMoZ2x1ZS5pbXBvcnRzKS5mb3JFYWNoKChpbXBvcnRLZXkpID0+IHtcbiAgICAgICAgICBpZiAoc3RhdGVbaW1wb3J0S2V5XSkge1xuICAgICAgICAgICAgZGVzY3JpcHRpb25JbXBvcnRzLmltcG9ydHNbaW1wb3J0S2V5XSA9IHN0YXRlW2ltcG9ydEtleV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkcmF3ZXJbaW1wb3J0S2V5XSkge1xuICAgICAgICAgICAgZGVzY3JpcHRpb25JbXBvcnRzLmltcG9ydHNbaW1wb3J0S2V5XSA9IGRyYXdlcltpbXBvcnRLZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGF0ZXNbaW1wb3J0S2V5XSkge1xuICAgICAgICAgICAgZGVzY3JpcHRpb25JbXBvcnRzLmltcG9ydHNbaW1wb3J0S2V5XSA9IGRhdGVzW2ltcG9ydEtleV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbXBvcnRLZXkgPT09IG1lbW9yeUltcG9ydCkge1xuICAgICAgICAgICAgZGVzY3JpcHRpb25JbXBvcnRzLmltcG9ydHNbaW1wb3J0S2V5XSA9IG1lbW9yeTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IG1vZHVsZUNvbXBpbGVkID0gYXdhaXQgV2ViQXNzZW1ibHkuY29tcGlsZShtb2R1bGUpO1xuICAgICAgICBjb25zdCBtb2R1bGVJbnN0YW5jZSA9IGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKFxuICAgICAgICAgIG1vZHVsZUNvbXBpbGVkLFxuICAgICAgICAgIGRlc2NyaXB0aW9uSW1wb3J0c1xuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IHByb2NlZHVyZSA9IG1vZHVsZUluc3RhbmNlLmV4cG9ydHNba2V5XTtcblxuICAgICAgICBpZiAocHJvY2VkdXJlKSB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gcHJvY2VkdXJlKCk7XG5cbiAgICAgICAgICByZXNvbHZlKG91dHB1dHMpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChbXG4gICAgICAgICAge1xuICAgICAgICAgICAgbWVzc2FnZTogZS5tZXNzYWdlLFxuICAgICAgICAgICAgdHlwZTogMTAwLFxuICAgICAgICAgICAgcG9zaXRpb246IDAsXG4gICAgICAgICAgICBsZW5ndGg6IDAsXG4gICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlamVjdChbXG4gICAgICAgIHtcbiAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgXCJFcnJvcjogTWlzc2luZyBtYWluIGZ1bmN0aW9uLiBFdmVyeSBGbG9ncmFtIHByb2dyYW0gbXVzdCBpbmNsdWRlIGFuIGVudHJ5IHBvaW50IGRlZmluZWQgYXMgdGhlIG1haW4gZnVuY3Rpb24uXCIsXG4gICAgICAgICAgdHlwZTogMTAxLFxuICAgICAgICAgIHBvc2l0aW9uOiAwLFxuICAgICAgICAgIGxlbmd0aDogMCxcbiAgICAgICAgfSxcbiAgICAgIF0pO1xuICAgIH1cbiAgfSk7XG5cbmNvbnN0IHJ1biA9ICh2YWx1ZSkgPT5cbiAgbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGZhaWx1cmVzID0gW107XG4gICAgbGV0IHJlcHJlc2VudGF0aW9uID0gbnVsbDtcblxuICAgIGNvbnN0IEVOQ09ERVIgPSBuZXcgVGV4dEVuY29kZXIoKTtcblxuICAgIGNvbnN0IHRva2VuaXplciA9IG5ldyBUb2tlbml6ZXIoKTtcblxuICAgIGNvbnN0IHBhcnNlciA9IFBhcnNlci5jcmVhdGUoe1xuICAgICAgcGF0aDogXCJNb2R1bGVcIixcbiAgICAgIGltcG9ydHM6IFNJTVBMRV9JTVBPUlRTLFxuICAgIH0pO1xuXG4gICAgcGFyc2VyLm9uKFBhcnNlci5FVkVOVF9GQUlMLCAoZmFpbHVyZSkgPT4ge1xuICAgICAgZmFpbHVyZXMgPSBbLi4uZmFpbHVyZXMsIGZhaWx1cmVdO1xuICAgICAgcmVwcmVzZW50YXRpb24gPSBudWxsO1xuICAgIH0pO1xuXG4gICAgcGFyc2VyLm9uKFBhcnNlci5FVkVOVF9ET05FLCAoZGF0YSkgPT4ge1xuICAgICAgcmVwcmVzZW50YXRpb24gPSBkYXRhO1xuICAgIH0pO1xuXG4gICAgdG9rZW5pemVyLm9uKFwidG9rZW5cIiwgKHBvc2l0aW9uLCBhcnJheSwgaW5kZXgsIGxlbmd0aCkgPT4ge1xuICAgICAgcGFyc2VyLmZlZWQocG9zaXRpb24sIGFycmF5LCBpbmRleCwgbGVuZ3RoKTtcbiAgICB9KTtcblxuICAgIHRva2VuaXplci5mZWVkKEVOQ09ERVIuZW5jb2RlKHZhbHVlKSk7XG5cbiAgICB0b2tlbml6ZXIuZG9uZSgpO1xuXG4gICAgcGFyc2VyLmRvbmUoKTtcblxuICAgIGlmIChyZXByZXNlbnRhdGlvbikge1xuICAgICAgY29uc3QgY29tcGlsZXJPcHRpb25zID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIG1lbW9yeTogdHJ1ZSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBbZ2x1ZSwgbW9kdWxlXSA9IENvbXBpbGVyLmNvbXBpbGUocmVwcmVzZW50YXRpb24sIGNvbXBpbGVyT3B0aW9ucyk7XG5cbiAgICAgIGV4ZWN1dGUoZ2x1ZSwgbW9kdWxlKVxuICAgICAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZShyZXMpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy9jb3VsZG4ndCBwYXJzZSwgcmV0dXJuIHBhcnNpbmcgZXJyb3JzXG4gICAgICByZWplY3QoZmFpbHVyZXMpO1xuICAgIH1cbiAgfSk7XG5cbmNvbnN0IG1vZHVsZSA9IHtcbiAgcnVuLFxuICBQYXJzZXIsXG4gIFRva2VuaXplcixcbiAgQ29tcGlsZXIsXG4gIE1lbW9yeU1hbmFnZXIsXG4gIERyYXcsXG4gIERhdGVzLFxuICBTSU1QTEVfSU1QT1JUUyxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG1vZHVsZTtcbiJdLCJuYW1lcyI6WyJUb2tlbml6ZXIiLCJQYXJzZXIiLCJDb21waWxlciIsImNyZWF0ZU1lbW9yeU1hbmFnZXIiLCJNZW1vcnlNYW5hZ2VyIiwiY3JlYXRlRHJhd2VyIiwiRHJhdyIsImNyZWF0ZURhdGUiLCJEYXRlcyIsIlNJTVBMRV9JTVBPUlRTIiwiZXhlY3V0ZSIsImdsdWUiLCJtb2R1bGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImtleSIsIm91dHB1dHMiLCJpS2V5IiwidmFsdWUiLCJPYmplY3QiLCJlbnRyaWVzIiwicHJvY2VkdXJlcyIsIm5hbWUiLCJwYXRoIiwibWVtb3J5IiwiV2ViQXNzZW1ibHkiLCJNZW1vcnkiLCJpbml0aWFsIiwic3RhdGUiLCJkcmF3ZXIiLCJkYXRlcyIsImRlc2NyaXB0aW9uSW1wb3J0cyIsImZyZWV6ZSIsImltcG9ydHMiLCJtZW1vcnlJbXBvcnQiLCJrZXlzIiwiZm9yRWFjaCIsImltcG9ydEtleSIsIm1vZHVsZUNvbXBpbGVkIiwiY29tcGlsZSIsIm1vZHVsZUluc3RhbmNlIiwiaW5zdGFudGlhdGUiLCJwcm9jZWR1cmUiLCJleHBvcnRzIiwiZSIsIm1lc3NhZ2UiLCJ0eXBlIiwicG9zaXRpb24iLCJsZW5ndGgiLCJydW4iLCJmYWlsdXJlcyIsInJlcHJlc2VudGF0aW9uIiwiRU5DT0RFUiIsIlRleHRFbmNvZGVyIiwidG9rZW5pemVyIiwicGFyc2VyIiwiY3JlYXRlIiwib24iLCJFVkVOVF9GQUlMIiwiZmFpbHVyZSIsIkVWRU5UX0RPTkUiLCJkYXRhIiwiYXJyYXkiLCJpbmRleCIsImZlZWQiLCJlbmNvZGUiLCJkb25lIiwiY29tcGlsZXJPcHRpb25zIiwidGhlbiIsInJlcyIsImNhdGNoIiwiZXJyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/@munezero/floparser/index.js\n"));

/***/ })

});