"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/@munezero/floparser/index.js":
/*!******************************************!*\
  !*** ./app/@munezero/floparser/index.js ***!
  \******************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Compiler: () => (/* reexport safe */ _Compilers_SimplerWASM_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   Dates: () => (/* reexport safe */ _Compilers_MemoryManager_index_mjs__WEBPACK_IMPORTED_MODULE_3__.createDate),\n/* harmony export */   Draw: () => (/* reexport safe */ _Compilers_MemoryManager_index_mjs__WEBPACK_IMPORTED_MODULE_3__.createDrawer),\n/* harmony export */   MemoryManager: () => (/* reexport safe */ _Compilers_MemoryManager_index_mjs__WEBPACK_IMPORTED_MODULE_3__.createMemoryManager),\n/* harmony export */   Parser: () => (/* reexport safe */ _SimpleParser_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   SIMPLE_IMPORTS: () => (/* reexport safe */ _Tests_Shared_index_mjs__WEBPACK_IMPORTED_MODULE_4__.SIMPLE_IMPORTS),\n/* harmony export */   Tokenizer: () => (/* reexport safe */ _Tokenizer_index_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   run: () => (/* binding */ run)\n/* harmony export */ });\n/* harmony import */ var _Tokenizer_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Tokenizer/index.mjs */ \"(app-pages-browser)/./app/@munezero/floparser/Tokenizer/index.mjs\");\n/* harmony import */ var _SimpleParser_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SimpleParser/index.mjs */ \"(app-pages-browser)/./app/@munezero/floparser/SimpleParser/index.mjs\");\n/* harmony import */ var _Compilers_SimplerWASM_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Compilers/SimplerWASM/index.mjs */ \"(app-pages-browser)/./app/@munezero/floparser/Compilers/SimplerWASM/index.mjs\");\n/* harmony import */ var _Compilers_MemoryManager_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Compilers/MemoryManager/index.mjs */ \"(app-pages-browser)/./app/@munezero/floparser/Compilers/MemoryManager/index.mjs\");\n/* harmony import */ var _Tests_Shared_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Tests/Shared/index.mjs */ \"(app-pages-browser)/./app/@munezero/floparser/Tests/Shared/index.mjs\");\n\n\n\n\n\n//npm publish --access=public\nconst execute = (glue, module)=>new Promise(async (resolve, reject)=>{\n        let key;\n        for (const [iKey, value] of Object.entries(glue.procedures)){\n            const { name, path } = value;\n            if (name === \"main\" && path === \"Module\") {\n                key = iKey;\n                break;\n            }\n        }\n        if (key) {\n            try {\n                const memory = new WebAssembly.Memory({\n                    initial: 128\n                });\n                const state = (0,_Compilers_MemoryManager_index_mjs__WEBPACK_IMPORTED_MODULE_3__.createMemoryManager)(memory);\n                const drawer = (0,_Compilers_MemoryManager_index_mjs__WEBPACK_IMPORTED_MODULE_3__.createDrawer)(memory, outputElement);\n                const dates = (0,_Compilers_MemoryManager_index_mjs__WEBPACK_IMPORTED_MODULE_3__.createDate)();\n                const descriptionImports = Object.freeze({\n                    imports: {}\n                });\n                const memoryImport = \"memory\";\n                Object.keys(glue.imports).forEach((importKey)=>{\n                    if (state[importKey]) {\n                        descriptionImports.imports[importKey] = state[importKey];\n                    }\n                    if (drawer[importKey]) {\n                        descriptionImports.imports[importKey] = drawer[importKey];\n                    }\n                    if (dates[importKey]) {\n                        descriptionImports.imports[importKey] = dates[importKey];\n                    }\n                    if (importKey === memoryImport) {\n                        descriptionImports.imports[importKey] = memory;\n                    }\n                });\n                const moduleCompiled = await WebAssembly.compile(module);\n                const moduleInstance = await WebAssembly.instantiate(moduleCompiled, descriptionImports);\n                const procedure = moduleInstance.exports[key];\n                if (procedure) {\n                    if (!outputElement) {\n                        failures.push({\n                            message: 'Error: Output element not found. Click \"Run\" again for re-evaluation',\n                            type: 100,\n                            position: 0,\n                            length: 0\n                        });\n                    }\n                    if (outputElement) {\n                        outputElement.innerHTML = \"\";\n                    }\n                    let value = procedure();\n                    if (outputElement) {\n                        output = outputElement.innerHTML;\n                    }\n                    resolve(output);\n                }\n            } catch (e) {\n                reject({\n                    message: e.message,\n                    type: 100,\n                    position: 0,\n                    length: 0\n                });\n            }\n        } else {\n            reject({\n                message: \"Error: Missing main function. Every Flogram program must include an entry point defined as the main function.\",\n                type: 101,\n                position: 0,\n                length: 0\n            });\n        }\n    });\nconst run = (value)=>new Promise(async (resolve, reject)=>{\n        let output1 = \"\";\n        const errors = [];\n        let representation = null;\n        const ENCODER = new TextEncoder();\n        const tokenizer = new _Tokenizer_index_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n        const parser = _SimpleParser_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].create({\n            path: \"Module\",\n            imports: _Tests_Shared_index_mjs__WEBPACK_IMPORTED_MODULE_4__.SIMPLE_IMPORTS\n        });\n        parser.on(_SimpleParser_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].EVENT_FAIL, (failure)=>{\n            failures = [\n                ...failures,\n                failure\n            ];\n            representation = null;\n        });\n        parser.on(_SimpleParser_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].EVENT_DONE, (data)=>{\n            representation = data;\n        });\n        tokenizer.on(\"token\", (position, array, index, length)=>{\n            parser.feed(position, array, index, length);\n        });\n        tokenizer.feed(ENCODER.encode(value));\n        tokenizer.done();\n        parser.done();\n        if (representation) {\n            const compilerOptions = Object.freeze({\n                memory: true\n            });\n            const [glue, module] = _Compilers_SimplerWASM_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].compile(representation, compilerOptions);\n            const value = await execute(glue, module);\n            console.log(\"value::: \", value);\n            return {\n                errors,\n                value\n            };\n        } else {\n            //couldn't parse, return parsing errors\n            return {\n                errors,\n                value: null\n            };\n        }\n    });\n// const runner = async ({value, outputElement}) => {\n//     let output = '';\n//     let failures = [];\n//     let representation = null;\n//     const ENCODER = new TextEncoder();\n//     const tokenizer = new Tokenizer();\n//     const parser = Parser.create({\n//         path: 'Module',\n//         imports: SIMPLE_IMPORTS\n//     });\n//     parser.on(Parser.EVENT_FAIL, (failure) => {\n//         failures = [...failures, failure];\n//         representation = null;\n//     });\n//     parser.on(Parser.EVENT_DONE, (data) => {\n//         representation = data;\n//     });\n//     tokenizer.on('token', (position, array, index, length) => {\n//         parser.feed(position, array, index, length);\n//     });\n//     tokenizer.feed(ENCODER.encode(value));\n//     tokenizer.done();\n//     parser.done();\n//     if (representation) {\n//         const compilerOptions = Object.freeze({\n//             memory: true\n//         });\n//         const [glue, module] = Compiler.compile(representation, compilerOptions);\n//         const value = await execute(glue, module);\n//         return { failures, value }\n//     }\n//     else{\n//         //couldn't parse, return parsing errors\n//         return { failures, value: null}\n//     }\n// };\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9AbXVuZXplcm8vZmxvcGFyc2VyL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEM7QUFDQTtBQUNXO0FBS1o7QUFDYTtBQUUxRCw2QkFBNkI7QUFFN0IsTUFBTVUsVUFBVSxDQUFDQyxNQUFNQyxTQUNyQixJQUFJQyxRQUFRLE9BQU9DLFNBQVNDO1FBQzFCLElBQUlDO1FBRUosS0FBSyxNQUFNLENBQUNDLE1BQU1DLE1BQU0sSUFBSUMsT0FBT0MsT0FBTyxDQUFDVCxLQUFLVSxVQUFVLEVBQUc7WUFDM0QsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLElBQUksRUFBRSxHQUFHTDtZQUN2QixJQUFJSSxTQUFTLFVBQVVDLFNBQVMsVUFBVTtnQkFDeENQLE1BQU1DO2dCQUNOO1lBQ0Y7UUFDRjtRQUVBLElBQUlELEtBQUs7WUFDUCxJQUFJO2dCQUNGLE1BQU1RLFNBQVMsSUFBSUMsWUFBWUMsTUFBTSxDQUFDO29CQUNwQ0MsU0FBUztnQkFDWDtnQkFFQSxNQUFNQyxRQUFReEIsdUZBQWFBLENBQUNvQjtnQkFDNUIsTUFBTUssU0FBU3ZCLGdGQUFJQSxDQUFDa0IsUUFBUU07Z0JBQzVCLE1BQU1DLFFBQVF2Qiw4RUFBS0E7Z0JBRW5CLE1BQU13QixxQkFBcUJiLE9BQU9jLE1BQU0sQ0FBQztvQkFDdkNDLFNBQVMsQ0FBQztnQkFDWjtnQkFFQSxNQUFNQyxlQUFlO2dCQUVyQmhCLE9BQU9pQixJQUFJLENBQUN6QixLQUFLdUIsT0FBTyxFQUFFRyxPQUFPLENBQUMsQ0FBQ0M7b0JBQ2pDLElBQUlWLEtBQUssQ0FBQ1UsVUFBVSxFQUFFO3dCQUNwQk4sbUJBQW1CRSxPQUFPLENBQUNJLFVBQVUsR0FBR1YsS0FBSyxDQUFDVSxVQUFVO29CQUMxRDtvQkFDQSxJQUFJVCxNQUFNLENBQUNTLFVBQVUsRUFBRTt3QkFDckJOLG1CQUFtQkUsT0FBTyxDQUFDSSxVQUFVLEdBQUdULE1BQU0sQ0FBQ1MsVUFBVTtv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QzFCLGtDQUFrQztBQUNsQyxVQUFVO0FBRVYsa0RBQWtEO0FBQ2xELDZDQUE2QztBQUM3QyxpQ0FBaUM7QUFDakMsVUFBVTtBQUVWLCtDQUErQztBQUMvQyxpQ0FBaUM7QUFDakMsVUFBVTtBQUVWLGtFQUFrRTtBQUNsRSx1REFBdUQ7QUFDdkQsVUFBVTtBQUVWLDZDQUE2QztBQUU3Qyx3QkFBd0I7QUFFeEIscUJBQXFCO0FBRXJCLDRCQUE0QjtBQUM1QixrREFBa0Q7QUFDbEQsMkJBQTJCO0FBQzNCLGNBQWM7QUFFZCxvRkFBb0Y7QUFDcEYscURBQXFEO0FBRXJELHFDQUFxQztBQUNyQyxRQUFRO0FBQ1IsWUFBWTtBQUNaLGtEQUFrRDtBQUNsRCwwQ0FBMEM7QUFDMUMsUUFBUTtBQUNSLEtBQUs7QUFXSCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxKQVNPTlxcRGVza3RvcFxcTmV3IGZvbGRlclxcYXBwXFxAbXVuZXplcm9cXGZsb3BhcnNlclxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFRva2VuaXplciBmcm9tIFwiLi9Ub2tlbml6ZXIvaW5kZXgubWpzXCI7XG5pbXBvcnQgUGFyc2VyIGZyb20gXCIuL1NpbXBsZVBhcnNlci9pbmRleC5tanNcIjtcbmltcG9ydCBDb21waWxlciBmcm9tIFwiLi9Db21waWxlcnMvU2ltcGxlcldBU00vaW5kZXgubWpzXCI7XG5pbXBvcnQge1xuICBjcmVhdGVNZW1vcnlNYW5hZ2VyIGFzIE1lbW9yeU1hbmFnZXIsXG4gIGNyZWF0ZURyYXdlciBhcyBEcmF3LFxuICBjcmVhdGVEYXRlIGFzIERhdGVzLFxufSBmcm9tIFwiLi9Db21waWxlcnMvTWVtb3J5TWFuYWdlci9pbmRleC5tanNcIjtcbmltcG9ydCB7IFNJTVBMRV9JTVBPUlRTIH0gZnJvbSBcIi4vVGVzdHMvU2hhcmVkL2luZGV4Lm1qc1wiO1xuXG4vL25wbSBwdWJsaXNoIC0tYWNjZXNzPXB1YmxpY1xuXG5jb25zdCBleGVjdXRlID0gKGdsdWUsIG1vZHVsZSkgPT5cbiAgbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGxldCBrZXk7XG5cbiAgICBmb3IgKGNvbnN0IFtpS2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZ2x1ZS5wcm9jZWR1cmVzKSkge1xuICAgICAgY29uc3QgeyBuYW1lLCBwYXRoIH0gPSB2YWx1ZTtcbiAgICAgIGlmIChuYW1lID09PSBcIm1haW5cIiAmJiBwYXRoID09PSBcIk1vZHVsZVwiKSB7XG4gICAgICAgIGtleSA9IGlLZXk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG1lbW9yeSA9IG5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe1xuICAgICAgICAgIGluaXRpYWw6IDEyOCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3Qgc3RhdGUgPSBNZW1vcnlNYW5hZ2VyKG1lbW9yeSk7XG4gICAgICAgIGNvbnN0IGRyYXdlciA9IERyYXcobWVtb3J5LCBvdXRwdXRFbGVtZW50KTtcbiAgICAgICAgY29uc3QgZGF0ZXMgPSBEYXRlcygpO1xuXG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uSW1wb3J0cyA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICAgIGltcG9ydHM6IHt9LFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBtZW1vcnlJbXBvcnQgPSBcIm1lbW9yeVwiO1xuXG4gICAgICAgIE9iamVjdC5rZXlzKGdsdWUuaW1wb3J0cykuZm9yRWFjaCgoaW1wb3J0S2V5KSA9PiB7XG4gICAgICAgICAgaWYgKHN0YXRlW2ltcG9ydEtleV0pIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uSW1wb3J0cy5pbXBvcnRzW2ltcG9ydEtleV0gPSBzdGF0ZVtpbXBvcnRLZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZHJhd2VyW2ltcG9ydEtleV0pIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uSW1wb3J0cy5pbXBvcnRzW2ltcG9ydEtleV0gPSBkcmF3ZXJbaW1wb3J0S2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRhdGVzW2ltcG9ydEtleV0pIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uSW1wb3J0cy5pbXBvcnRzW2ltcG9ydEtleV0gPSBkYXRlc1tpbXBvcnRLZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW1wb3J0S2V5ID09PSBtZW1vcnlJbXBvcnQpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uSW1wb3J0cy5pbXBvcnRzW2ltcG9ydEtleV0gPSBtZW1vcnk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBtb2R1bGVDb21waWxlZCA9IGF3YWl0IFdlYkFzc2VtYmx5LmNvbXBpbGUobW9kdWxlKTtcbiAgICAgICAgY29uc3QgbW9kdWxlSW5zdGFuY2UgPSBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShcbiAgICAgICAgICBtb2R1bGVDb21waWxlZCxcbiAgICAgICAgICBkZXNjcmlwdGlvbkltcG9ydHNcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBwcm9jZWR1cmUgPSBtb2R1bGVJbnN0YW5jZS5leHBvcnRzW2tleV07XG4gICAgICAgIGlmIChwcm9jZWR1cmUpIHtcbiAgICAgICAgICBpZiAoIW91dHB1dEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGZhaWx1cmVzLnB1c2goe1xuICAgICAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgICAgICdFcnJvcjogT3V0cHV0IGVsZW1lbnQgbm90IGZvdW5kLiBDbGljayBcIlJ1blwiIGFnYWluIGZvciByZS1ldmFsdWF0aW9uJyxcbiAgICAgICAgICAgICAgdHlwZTogMTAwLFxuICAgICAgICAgICAgICBwb3NpdGlvbjogMCxcbiAgICAgICAgICAgICAgbGVuZ3RoOiAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG91dHB1dEVsZW1lbnQpIHtcbiAgICAgICAgICAgIG91dHB1dEVsZW1lbnQuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgdmFsdWUgPSBwcm9jZWR1cmUoKTtcblxuICAgICAgICAgIGlmIChvdXRwdXRFbGVtZW50KSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXRFbGVtZW50LmlubmVySFRNTDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXNvbHZlKG91dHB1dCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICBtZXNzYWdlOiBlLm1lc3NhZ2UsXG4gICAgICAgICAgdHlwZTogMTAwLFxuICAgICAgICAgIHBvc2l0aW9uOiAwLFxuICAgICAgICAgIGxlbmd0aDogMCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlamVjdCh7XG4gICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgXCJFcnJvcjogTWlzc2luZyBtYWluIGZ1bmN0aW9uLiBFdmVyeSBGbG9ncmFtIHByb2dyYW0gbXVzdCBpbmNsdWRlIGFuIGVudHJ5IHBvaW50IGRlZmluZWQgYXMgdGhlIG1haW4gZnVuY3Rpb24uXCIsXG4gICAgICAgIHR5cGU6IDEwMSxcbiAgICAgICAgcG9zaXRpb246IDAsXG4gICAgICAgIGxlbmd0aDogMCxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbmNvbnN0IHJ1biA9ICh2YWx1ZSkgPT5cbiAgbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGxldCBvdXRwdXQgPSBcIlwiO1xuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuXG4gICAgbGV0IHJlcHJlc2VudGF0aW9uID0gbnVsbDtcblxuICAgIGNvbnN0IEVOQ09ERVIgPSBuZXcgVGV4dEVuY29kZXIoKTtcblxuICAgIGNvbnN0IHRva2VuaXplciA9IG5ldyBUb2tlbml6ZXIoKTtcblxuICAgIGNvbnN0IHBhcnNlciA9IFBhcnNlci5jcmVhdGUoe1xuICAgICAgcGF0aDogXCJNb2R1bGVcIixcbiAgICAgIGltcG9ydHM6IFNJTVBMRV9JTVBPUlRTLFxuICAgIH0pO1xuXG4gICAgcGFyc2VyLm9uKFBhcnNlci5FVkVOVF9GQUlMLCAoZmFpbHVyZSkgPT4ge1xuICAgICAgZmFpbHVyZXMgPSBbLi4uZmFpbHVyZXMsIGZhaWx1cmVdO1xuICAgICAgcmVwcmVzZW50YXRpb24gPSBudWxsO1xuICAgIH0pO1xuXG4gICAgcGFyc2VyLm9uKFBhcnNlci5FVkVOVF9ET05FLCAoZGF0YSkgPT4ge1xuICAgICAgcmVwcmVzZW50YXRpb24gPSBkYXRhO1xuICAgIH0pO1xuXG4gICAgdG9rZW5pemVyLm9uKFwidG9rZW5cIiwgKHBvc2l0aW9uLCBhcnJheSwgaW5kZXgsIGxlbmd0aCkgPT4ge1xuICAgICAgcGFyc2VyLmZlZWQocG9zaXRpb24sIGFycmF5LCBpbmRleCwgbGVuZ3RoKTtcbiAgICB9KTtcblxuICAgIHRva2VuaXplci5mZWVkKEVOQ09ERVIuZW5jb2RlKHZhbHVlKSk7XG5cbiAgICB0b2tlbml6ZXIuZG9uZSgpO1xuXG4gICAgcGFyc2VyLmRvbmUoKTtcblxuICAgIGlmIChyZXByZXNlbnRhdGlvbikge1xuICAgICAgY29uc3QgY29tcGlsZXJPcHRpb25zID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIG1lbW9yeTogdHJ1ZSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBbZ2x1ZSwgbW9kdWxlXSA9IENvbXBpbGVyLmNvbXBpbGUocmVwcmVzZW50YXRpb24sIGNvbXBpbGVyT3B0aW9ucyk7XG4gICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoZ2x1ZSwgbW9kdWxlKTtcbiAgICAgIGNvbnNvbGUubG9nKFwidmFsdWU6OjogXCIsIHZhbHVlKTtcblxuICAgICAgcmV0dXJuIHsgZXJyb3JzLCB2YWx1ZSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvL2NvdWxkbid0IHBhcnNlLCByZXR1cm4gcGFyc2luZyBlcnJvcnNcbiAgICAgIHJldHVybiB7IGVycm9ycywgdmFsdWU6IG51bGwgfTtcbiAgICB9XG4gIH0pO1xuXG4vLyBjb25zdCBydW5uZXIgPSBhc3luYyAoe3ZhbHVlLCBvdXRwdXRFbGVtZW50fSkgPT4ge1xuLy8gICAgIGxldCBvdXRwdXQgPSAnJztcblxuLy8gICAgIGxldCBmYWlsdXJlcyA9IFtdO1xuXG4vLyAgICAgbGV0IHJlcHJlc2VudGF0aW9uID0gbnVsbDtcblxuLy8gICAgIGNvbnN0IEVOQ09ERVIgPSBuZXcgVGV4dEVuY29kZXIoKTtcblxuLy8gICAgIGNvbnN0IHRva2VuaXplciA9IG5ldyBUb2tlbml6ZXIoKTtcblxuLy8gICAgIGNvbnN0IHBhcnNlciA9IFBhcnNlci5jcmVhdGUoe1xuLy8gICAgICAgICBwYXRoOiAnTW9kdWxlJyxcbi8vICAgICAgICAgaW1wb3J0czogU0lNUExFX0lNUE9SVFNcbi8vICAgICB9KTtcblxuLy8gICAgIHBhcnNlci5vbihQYXJzZXIuRVZFTlRfRkFJTCwgKGZhaWx1cmUpID0+IHtcbi8vICAgICAgICAgZmFpbHVyZXMgPSBbLi4uZmFpbHVyZXMsIGZhaWx1cmVdO1xuLy8gICAgICAgICByZXByZXNlbnRhdGlvbiA9IG51bGw7XG4vLyAgICAgfSk7XG5cbi8vICAgICBwYXJzZXIub24oUGFyc2VyLkVWRU5UX0RPTkUsIChkYXRhKSA9PiB7XG4vLyAgICAgICAgIHJlcHJlc2VudGF0aW9uID0gZGF0YTtcbi8vICAgICB9KTtcblxuLy8gICAgIHRva2VuaXplci5vbigndG9rZW4nLCAocG9zaXRpb24sIGFycmF5LCBpbmRleCwgbGVuZ3RoKSA9PiB7XG4vLyAgICAgICAgIHBhcnNlci5mZWVkKHBvc2l0aW9uLCBhcnJheSwgaW5kZXgsIGxlbmd0aCk7XG4vLyAgICAgfSk7XG5cbi8vICAgICB0b2tlbml6ZXIuZmVlZChFTkNPREVSLmVuY29kZSh2YWx1ZSkpO1xuXG4vLyAgICAgdG9rZW5pemVyLmRvbmUoKTtcblxuLy8gICAgIHBhcnNlci5kb25lKCk7XG5cbi8vICAgICBpZiAocmVwcmVzZW50YXRpb24pIHtcbi8vICAgICAgICAgY29uc3QgY29tcGlsZXJPcHRpb25zID0gT2JqZWN0LmZyZWV6ZSh7XG4vLyAgICAgICAgICAgICBtZW1vcnk6IHRydWVcbi8vICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgY29uc3QgW2dsdWUsIG1vZHVsZV0gPSBDb21waWxlci5jb21waWxlKHJlcHJlc2VudGF0aW9uLCBjb21waWxlck9wdGlvbnMpO1xuLy8gICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoZ2x1ZSwgbW9kdWxlKTtcblxuLy8gICAgICAgICByZXR1cm4geyBmYWlsdXJlcywgdmFsdWUgfVxuLy8gICAgIH1cbi8vICAgICBlbHNle1xuLy8gICAgICAgICAvL2NvdWxkbid0IHBhcnNlLCByZXR1cm4gcGFyc2luZyBlcnJvcnNcbi8vICAgICAgICAgcmV0dXJuIHsgZmFpbHVyZXMsIHZhbHVlOiBudWxsfVxuLy8gICAgIH1cbi8vIH07XG5cbmV4cG9ydCB7XG4gIHJ1bixcbiAgUGFyc2VyLFxuICBUb2tlbml6ZXIsXG4gIENvbXBpbGVyLFxuICBNZW1vcnlNYW5hZ2VyLFxuICBEcmF3LFxuICBEYXRlcyxcbiAgU0lNUExFX0lNUE9SVFMsXG59O1xuIl0sIm5hbWVzIjpbIlRva2VuaXplciIsIlBhcnNlciIsIkNvbXBpbGVyIiwiY3JlYXRlTWVtb3J5TWFuYWdlciIsIk1lbW9yeU1hbmFnZXIiLCJjcmVhdGVEcmF3ZXIiLCJEcmF3IiwiY3JlYXRlRGF0ZSIsIkRhdGVzIiwiU0lNUExFX0lNUE9SVFMiLCJleGVjdXRlIiwiZ2x1ZSIsIm1vZHVsZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0Iiwia2V5IiwiaUtleSIsInZhbHVlIiwiT2JqZWN0IiwiZW50cmllcyIsInByb2NlZHVyZXMiLCJuYW1lIiwicGF0aCIsIm1lbW9yeSIsIldlYkFzc2VtYmx5IiwiTWVtb3J5IiwiaW5pdGlhbCIsInN0YXRlIiwiZHJhd2VyIiwib3V0cHV0RWxlbWVudCIsImRhdGVzIiwiZGVzY3JpcHRpb25JbXBvcnRzIiwiZnJlZXplIiwiaW1wb3J0cyIsIm1lbW9yeUltcG9ydCIsImtleXMiLCJmb3JFYWNoIiwiaW1wb3J0S2V5IiwibW9kdWxlQ29tcGlsZWQiLCJjb21waWxlIiwibW9kdWxlSW5zdGFuY2UiLCJpbnN0YW50aWF0ZSIsInByb2NlZHVyZSIsImV4cG9ydHMiLCJmYWlsdXJlcyIsInB1c2giLCJtZXNzYWdlIiwidHlwZSIsInBvc2l0aW9uIiwibGVuZ3RoIiwiaW5uZXJIVE1MIiwib3V0cHV0IiwiZSIsInJ1biIsImVycm9ycyIsInJlcHJlc2VudGF0aW9uIiwiRU5DT0RFUiIsIlRleHRFbmNvZGVyIiwidG9rZW5pemVyIiwicGFyc2VyIiwiY3JlYXRlIiwib24iLCJFVkVOVF9GQUlMIiwiZmFpbHVyZSIsIkVWRU5UX0RPTkUiLCJkYXRhIiwiYXJyYXkiLCJpbmRleCIsImZlZWQiLCJlbmNvZGUiLCJkb25lIiwiY29tcGlsZXJPcHRpb25zIiwiY29uc29sZSIsImxvZyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/@munezero/floparser/index.js\n"));

/***/ })

});