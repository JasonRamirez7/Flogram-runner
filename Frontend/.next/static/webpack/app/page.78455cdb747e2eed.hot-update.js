"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/@munezero/floparser/index.js":
/*!******************************************!*\
  !*** ./app/@munezero/floparser/index.js ***!
  \******************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Compiler: () => (/* reexport safe */ _Compilers_SimplerWASM_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   Dates: () => (/* reexport safe */ _Compilers_MemoryManager_index_mjs__WEBPACK_IMPORTED_MODULE_3__.createDate),\n/* harmony export */   Draw: () => (/* reexport safe */ _Compilers_MemoryManager_index_mjs__WEBPACK_IMPORTED_MODULE_3__.createDrawer),\n/* harmony export */   MemoryManager: () => (/* reexport safe */ _Compilers_MemoryManager_index_mjs__WEBPACK_IMPORTED_MODULE_3__.createMemoryManager),\n/* harmony export */   Parser: () => (/* reexport safe */ _SimpleParser_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   SIMPLE_IMPORTS: () => (/* reexport safe */ _Tests_Shared_index_mjs__WEBPACK_IMPORTED_MODULE_4__.SIMPLE_IMPORTS),\n/* harmony export */   Tokenizer: () => (/* reexport safe */ _Tokenizer_index_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   runner: () => (/* binding */ runner)\n/* harmony export */ });\n/* harmony import */ var _Tokenizer_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Tokenizer/index.mjs */ \"(app-pages-browser)/./app/@munezero/floparser/Tokenizer/index.mjs\");\n/* harmony import */ var _SimpleParser_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SimpleParser/index.mjs */ \"(app-pages-browser)/./app/@munezero/floparser/SimpleParser/index.mjs\");\n/* harmony import */ var _Compilers_SimplerWASM_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Compilers/SimplerWASM/index.mjs */ \"(app-pages-browser)/./app/@munezero/floparser/Compilers/SimplerWASM/index.mjs\");\n/* harmony import */ var _Compilers_MemoryManager_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Compilers/MemoryManager/index.mjs */ \"(app-pages-browser)/./app/@munezero/floparser/Compilers/MemoryManager/index.mjs\");\n/* harmony import */ var _Tests_Shared_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Tests/Shared/index.mjs */ \"(app-pages-browser)/./app/@munezero/floparser/Tests/Shared/index.mjs\");\n\n\n\n\n\n//npm publish --access=public\nconst runner = async (param)=>{\n    let { value, outputElement } = param;\n    let output = '';\n    let failures = [];\n    let representation = null;\n    const ENCODER = new TextEncoder();\n    const tokenizer = new _Tokenizer_index_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n    const parser = _SimpleParser_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].create({\n        path: 'Module',\n        imports: _Tests_Shared_index_mjs__WEBPACK_IMPORTED_MODULE_4__.SIMPLE_IMPORTS\n    });\n    parser.on(_SimpleParser_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].EVENT_FAIL, (failure)=>{\n        failures = [\n            ...failures,\n            failure\n        ];\n        representation = null;\n    });\n    parser.on(_SimpleParser_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].EVENT_DONE, (data)=>{\n        representation = data;\n    });\n    tokenizer.on('token', (position, array, index, length)=>{\n        parser.feed(position, array, index, length);\n    });\n    tokenizer.feed(ENCODER.encode(value));\n    tokenizer.done();\n    parser.done();\n    const execute = async (glue, module)=>{\n        let key;\n        for (const [iKey, value] of Object.entries(glue.procedures)){\n            const { name, path } = value;\n            if (name === 'main' && path === 'Module') {\n                key = iKey;\n                break;\n            }\n        }\n        if (key) {\n            try {\n                const memory = new WebAssembly.Memory({\n                    initial: 128\n                });\n                const state = (0,_Compilers_MemoryManager_index_mjs__WEBPACK_IMPORTED_MODULE_3__.createMemoryManager)(memory);\n                const drawer = (0,_Compilers_MemoryManager_index_mjs__WEBPACK_IMPORTED_MODULE_3__.createDrawer)(memory, outputElement);\n                const dates = (0,_Compilers_MemoryManager_index_mjs__WEBPACK_IMPORTED_MODULE_3__.createDate)();\n                const descriptionImports = Object.freeze({\n                    imports: {}\n                });\n                const memoryImport = 'memory';\n                Object.keys(glue.imports).forEach((importKey)=>{\n                    if (state[importKey]) {\n                        descriptionImports.imports[importKey] = state[importKey];\n                    }\n                    if (drawer[importKey]) {\n                        descriptionImports.imports[importKey] = drawer[importKey];\n                    }\n                    if (dates[importKey]) {\n                        descriptionImports.imports[importKey] = dates[importKey];\n                    }\n                    if (importKey === memoryImport) {\n                        descriptionImports.imports[importKey] = memory;\n                    }\n                });\n                const moduleCompiled = await WebAssembly.compile(module);\n                const moduleInstance = await WebAssembly.instantiate(moduleCompiled, descriptionImports);\n                const procedure = moduleInstance.exports[key];\n                if (procedure) {\n                    if (!outputElement) {\n                        failures.push({\n                            message: 'Error: Output element not found. Click \"Run\" again for re-evaluation',\n                            type: 100,\n                            position: 0,\n                            length: 0\n                        });\n                    }\n                    if (outputElement) {\n                        outputElement.innerHTML = '';\n                    }\n                    let value = procedure();\n                    if (outputElement) {\n                        output = outputElement.innerHTML;\n                    }\n                    console.log(\"HEllo world\");\n                    return output;\n                }\n            } catch (e) {\n                failures.push({\n                    message: e.message,\n                    type: 100,\n                    position: 0,\n                    length: 0\n                });\n                return null;\n            }\n        } else {\n            failures.push({\n                message: 'Error: Missing main function. Every Flogram program must include an entry point defined as the main function.',\n                type: 101,\n                position: 0,\n                length: 0\n            });\n            return null;\n        }\n    };\n    if (representation) {\n        const compilerOptions = Object.freeze({\n            memory: true\n        });\n        const [glue, module] = _Compilers_SimplerWASM_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].compile(representation, compilerOptions);\n        const value = await execute(glue, module);\n        return {\n            failures,\n            value\n        };\n    } else {\n        //couldn't parse, return parsing errors\n        return {\n            failures,\n            value: null\n        };\n    }\n};\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9AbXVuZXplcm8vZmxvcGFyc2VyL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNkM7QUFDQTtBQUNXO0FBQzRFO0FBQzNFO0FBRXpELDZCQUE2QjtBQUU3QixNQUFNVSxTQUFTO1FBQU8sRUFBQ0MsS0FBSyxFQUFFQyxhQUFhLEVBQUM7SUFDeEMsSUFBSUMsU0FBUztJQUViLElBQUlDLFdBQVcsRUFBRTtJQUVqQixJQUFJQyxpQkFBaUI7SUFFckIsTUFBTUMsVUFBVSxJQUFJQztJQUVwQixNQUFNQyxZQUFZLElBQUlsQiw0REFBU0E7SUFFL0IsTUFBTW1CLFNBQVNsQiwrREFBTUEsQ0FBQ21CLE1BQU0sQ0FBQztRQUN6QkMsTUFBTTtRQUNOQyxTQUFTYixtRUFBY0E7SUFDM0I7SUFFQVUsT0FBT0ksRUFBRSxDQUFDdEIsK0RBQU1BLENBQUN1QixVQUFVLEVBQUUsQ0FBQ0M7UUFDMUJYLFdBQVc7ZUFBSUE7WUFBVVc7U0FBUTtRQUNqQ1YsaUJBQWlCO0lBQ3JCO0lBRUFJLE9BQU9JLEVBQUUsQ0FBQ3RCLCtEQUFNQSxDQUFDeUIsVUFBVSxFQUFFLENBQUNDO1FBQzFCWixpQkFBaUJZO0lBQ3JCO0lBRUFULFVBQVVLLEVBQUUsQ0FBQyxTQUFTLENBQUNLLFVBQVVDLE9BQU9DLE9BQU9DO1FBQzNDWixPQUFPYSxJQUFJLENBQUNKLFVBQVVDLE9BQU9DLE9BQU9DO0lBQ3hDO0lBRUFiLFVBQVVjLElBQUksQ0FBQ2hCLFFBQVFpQixNQUFNLENBQUN0QjtJQUU5Qk8sVUFBVWdCLElBQUk7SUFFZGYsT0FBT2UsSUFBSTtJQUVYLE1BQU1DLFVBQVUsT0FBT0MsTUFBTUM7UUFDekIsSUFBSUM7UUFDSixLQUFLLE1BQU0sQ0FBQ0MsTUFBTTVCLE1BQU0sSUFBSTZCLE9BQU9DLE9BQU8sQ0FBQ0wsS0FBS00sVUFBVSxFQUFHO1lBQ3pELE1BQU0sRUFBRUMsSUFBSSxFQUFFdEIsSUFBSSxFQUFFLEdBQUdWO1lBQ3ZCLElBQUlnQyxTQUFTLFVBQVV0QixTQUFTLFVBQVU7Z0JBQ3RDaUIsTUFBTUM7Z0JBQ047WUFDSjtRQUNKO1FBQ0EsSUFBSUQsS0FBSztZQUNMLElBQUk7Z0JBQ0EsTUFBTU0sU0FBUyxJQUFJQyxZQUFZQyxNQUFNLENBQUM7b0JBQ2xDQyxTQUFTO2dCQUNiO2dCQUVBLE1BQU1DLFFBQVE1Qyx1RkFBYUEsQ0FBQ3dDO2dCQUM1QixNQUFNSyxTQUFTM0MsZ0ZBQUlBLENBQUNzQyxRQUFRaEM7Z0JBQzVCLE1BQU1zQyxRQUFRMUMsOEVBQUtBO2dCQUVuQixNQUFNMkMscUJBQXFCWCxPQUFPWSxNQUFNLENBQUM7b0JBQ3JDOUIsU0FBUyxDQUFDO2dCQUNkO2dCQUVBLE1BQU0rQixlQUFlO2dCQUVyQmIsT0FBT2MsSUFBSSxDQUFDbEIsS0FBS2QsT0FBTyxFQUFFaUMsT0FBTyxDQUFDLENBQUNDO29CQUMvQixJQUFJUixLQUFLLENBQUNRLFVBQVUsRUFBRTt3QkFDbEJMLG1CQUFtQjdCLE9BQU8sQ0FBQ2tDLFVBQVUsR0FBR1IsS0FBSyxDQUFDUSxVQUFVO29CQUM1RDtvQkFDQSxJQUFJUCxNQUFNLENBQUNPLFVBQVUsRUFBRTt3QkFDbkJMLG1CQUFtQjdCLE9BQU8sQ0FBQ2tDLFVBQVUsR0FBR1AsTUFBTSxDQUFDTyxVQUFVO29CQUM3RDtvQkFDQSxJQUFJTixLQUFLLENBQUNNLFVBQVUsRUFBRTt3QkFDbEJMLG1CQUFtQjdCLE9BQU8sQ0FBQ2tDLFVBQVUsR0FBR04sS0FBSyxDQUFDTSxVQUFVO29CQUM1RDtvQkFDQSxJQUFJQSxjQUFjSCxjQUFjO3dCQUM1QkYsbUJBQW1CN0IsT0FBTyxDQUFDa0MsVUFBVSxHQUFHWjtvQkFDNUM7Z0JBQ0o7Z0JBRUEsTUFBTWEsaUJBQWlCLE1BQU1aLFlBQVlhLE9BQU8sQ0FBQ3JCO2dCQUNqRCxNQUFNc0IsaUJBQWlCLE1BQU1kLFlBQVllLFdBQVcsQ0FBQ0gsZ0JBQWdCTjtnQkFFckUsTUFBTVUsWUFBWUYsZUFBZUcsT0FBTyxDQUFDeEIsSUFBSTtnQkFDN0MsSUFBSXVCLFdBQVc7b0JBQ1gsSUFBSSxDQUFDakQsZUFBZTt3QkFDaEJFLFNBQVNpRCxJQUFJLENBQUM7NEJBQ1ZDLFNBQVM7NEJBQ1RDLE1BQU07NEJBQ05yQyxVQUFVOzRCQUNWRyxRQUFRO3dCQUNaO29CQUNKO29CQUVBLElBQUluQixlQUFlO3dCQUNmQSxjQUFjc0QsU0FBUyxHQUFHO29CQUM5QjtvQkFDQSxJQUFJdkQsUUFBUWtEO29CQUVaLElBQUlqRCxlQUFjO3dCQUNkQyxTQUFTRCxjQUFjc0QsU0FBUztvQkFDcEM7b0JBRUFDLFFBQVFDLEdBQUcsQ0FBQztvQkFDWixPQUFPdkQ7Z0JBQ1g7WUFDSixFQUFFLE9BQU93RCxHQUFHO2dCQUNSdkQsU0FBU2lELElBQUksQ0FBQztvQkFDVkMsU0FBU0ssRUFBRUwsT0FBTztvQkFDbEJDLE1BQU07b0JBQ05yQyxVQUFVO29CQUNWRyxRQUFRO2dCQUNaO2dCQUNBLE9BQU87WUFDWDtRQUNKLE9BQ0k7WUFDQWpCLFNBQVNpRCxJQUFJLENBQUM7Z0JBQ1ZDLFNBQVM7Z0JBQ1RDLE1BQU07Z0JBQ05yQyxVQUFVO2dCQUNWRyxRQUFRO1lBQ1o7WUFFQSxPQUFPO1FBQ1g7SUFDSjtJQUVBLElBQUloQixnQkFBZ0I7UUFDaEIsTUFBTXVELGtCQUFrQjlCLE9BQU9ZLE1BQU0sQ0FBQztZQUNsQ1IsUUFBUTtRQUNaO1FBRUEsTUFBTSxDQUFDUixNQUFNQyxPQUFPLEdBQUduQyx3RUFBUUEsQ0FBQ3dELE9BQU8sQ0FBQzNDLGdCQUFnQnVEO1FBQ3hELE1BQU0zRCxRQUFRLE1BQU13QixRQUFRQyxNQUFNQztRQUVsQyxPQUFPO1lBQUV2QjtZQUFVSDtRQUFNO0lBQzdCLE9BQ0k7UUFDQSx1Q0FBdUM7UUFDdkMsT0FBTztZQUFFRztZQUFVSCxPQUFPO1FBQUk7SUFDbEM7QUFDSjtBQUV3RiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxKQVNPTlxcRGVza3RvcFxcTmV3IGZvbGRlclxcYXBwXFxAbXVuZXplcm9cXGZsb3BhcnNlclxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFRva2VuaXplciBmcm9tICcuL1Rva2VuaXplci9pbmRleC5tanMnXG5pbXBvcnQgUGFyc2VyIGZyb20gJy4vU2ltcGxlUGFyc2VyL2luZGV4Lm1qcydcbmltcG9ydCBDb21waWxlciBmcm9tICcuL0NvbXBpbGVycy9TaW1wbGVyV0FTTS9pbmRleC5tanMnXG5pbXBvcnQgeyBjcmVhdGVNZW1vcnlNYW5hZ2VyIGFzIE1lbW9yeU1hbmFnZXIsIGNyZWF0ZURyYXdlciBhcyBEcmF3LCBjcmVhdGVEYXRlIGFzIERhdGVzfSBmcm9tICcuL0NvbXBpbGVycy9NZW1vcnlNYW5hZ2VyL2luZGV4Lm1qcydcbmltcG9ydCB7IFNJTVBMRV9JTVBPUlRTIH0gZnJvbSAnLi9UZXN0cy9TaGFyZWQvaW5kZXgubWpzJ1xuXG4vL25wbSBwdWJsaXNoIC0tYWNjZXNzPXB1YmxpY1xuXG5jb25zdCBydW5uZXIgPSBhc3luYyAoe3ZhbHVlLCBvdXRwdXRFbGVtZW50fSkgPT4ge1xuICAgIGxldCBvdXRwdXQgPSAnJztcblxuICAgIGxldCBmYWlsdXJlcyA9IFtdO1xuXG4gICAgbGV0IHJlcHJlc2VudGF0aW9uID0gbnVsbDtcblxuICAgIGNvbnN0IEVOQ09ERVIgPSBuZXcgVGV4dEVuY29kZXIoKTtcblxuICAgIGNvbnN0IHRva2VuaXplciA9IG5ldyBUb2tlbml6ZXIoKTtcblxuICAgIGNvbnN0IHBhcnNlciA9IFBhcnNlci5jcmVhdGUoe1xuICAgICAgICBwYXRoOiAnTW9kdWxlJyxcbiAgICAgICAgaW1wb3J0czogU0lNUExFX0lNUE9SVFNcbiAgICB9KTtcblxuICAgIHBhcnNlci5vbihQYXJzZXIuRVZFTlRfRkFJTCwgKGZhaWx1cmUpID0+IHtcbiAgICAgICAgZmFpbHVyZXMgPSBbLi4uZmFpbHVyZXMsIGZhaWx1cmVdO1xuICAgICAgICByZXByZXNlbnRhdGlvbiA9IG51bGw7XG4gICAgfSk7XG5cbiAgICBwYXJzZXIub24oUGFyc2VyLkVWRU5UX0RPTkUsIChkYXRhKSA9PiB7XG4gICAgICAgIHJlcHJlc2VudGF0aW9uID0gZGF0YTtcbiAgICB9KTtcblxuICAgIHRva2VuaXplci5vbigndG9rZW4nLCAocG9zaXRpb24sIGFycmF5LCBpbmRleCwgbGVuZ3RoKSA9PiB7XG4gICAgICAgIHBhcnNlci5mZWVkKHBvc2l0aW9uLCBhcnJheSwgaW5kZXgsIGxlbmd0aCk7XG4gICAgfSk7XG5cbiAgICB0b2tlbml6ZXIuZmVlZChFTkNPREVSLmVuY29kZSh2YWx1ZSkpO1xuXG4gICAgdG9rZW5pemVyLmRvbmUoKTtcblxuICAgIHBhcnNlci5kb25lKCk7XG5cbiAgICBjb25zdCBleGVjdXRlID0gYXN5bmMgKGdsdWUsIG1vZHVsZSkgPT4ge1xuICAgICAgICBsZXQga2V5O1xuICAgICAgICBmb3IgKGNvbnN0IFtpS2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZ2x1ZS5wcm9jZWR1cmVzKSkge1xuICAgICAgICAgICAgY29uc3QgeyBuYW1lLCBwYXRoIH0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnbWFpbicgJiYgcGF0aCA9PT0gJ01vZHVsZScpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBpS2V5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVtb3J5ID0gbmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7XG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWw6IDEyOFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBNZW1vcnlNYW5hZ2VyKG1lbW9yeSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZHJhd2VyID0gRHJhdyhtZW1vcnksIG91dHB1dEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGVzID0gRGF0ZXMoKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uSW1wb3J0cyA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICAgICAgICAgICAgICBpbXBvcnRzOiB7fVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbWVtb3J5SW1wb3J0ID0gJ21lbW9yeSc7XG5cbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhnbHVlLmltcG9ydHMpLmZvckVhY2goKGltcG9ydEtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGVbaW1wb3J0S2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb25JbXBvcnRzLmltcG9ydHNbaW1wb3J0S2V5XSA9IHN0YXRlW2ltcG9ydEtleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRyYXdlcltpbXBvcnRLZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbkltcG9ydHMuaW1wb3J0c1tpbXBvcnRLZXldID0gZHJhd2VyW2ltcG9ydEtleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGVzW2ltcG9ydEtleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uSW1wb3J0cy5pbXBvcnRzW2ltcG9ydEtleV0gPSBkYXRlc1tpbXBvcnRLZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbXBvcnRLZXkgPT09IG1lbW9yeUltcG9ydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb25JbXBvcnRzLmltcG9ydHNbaW1wb3J0S2V5XSA9IG1lbW9yeTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbW9kdWxlQ29tcGlsZWQgPSBhd2FpdCBXZWJBc3NlbWJseS5jb21waWxlKG1vZHVsZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kdWxlSW5zdGFuY2UgPSBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShtb2R1bGVDb21waWxlZCwgZGVzY3JpcHRpb25JbXBvcnRzKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHByb2NlZHVyZSA9IG1vZHVsZUluc3RhbmNlLmV4cG9ydHNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2VkdXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb3V0cHV0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbHVyZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ0Vycm9yOiBPdXRwdXQgZWxlbWVudCBub3QgZm91bmQuIENsaWNrIFwiUnVuXCIgYWdhaW4gZm9yIHJlLWV2YWx1YXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IDEwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0RWxlbWVudC5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBwcm9jZWR1cmUoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0RWxlbWVudCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXRFbGVtZW50LmlubmVySFRNTDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSEVsbG8gd29ybGRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZmFpbHVyZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGUubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogMTAwLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogMCxcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiAwXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgICAgZmFpbHVyZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ0Vycm9yOiBNaXNzaW5nIG1haW4gZnVuY3Rpb24uIEV2ZXJ5IEZsb2dyYW0gcHJvZ3JhbSBtdXN0IGluY2x1ZGUgYW4gZW50cnkgcG9pbnQgZGVmaW5lZCBhcyB0aGUgbWFpbiBmdW5jdGlvbi4nLFxuICAgICAgICAgICAgICAgIHR5cGU6IDEwMSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogMCxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IDBcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGlmIChyZXByZXNlbnRhdGlvbikge1xuICAgICAgICBjb25zdCBjb21waWxlck9wdGlvbnMgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgICAgIG1lbW9yeTogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBbZ2x1ZSwgbW9kdWxlXSA9IENvbXBpbGVyLmNvbXBpbGUocmVwcmVzZW50YXRpb24sIGNvbXBpbGVyT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShnbHVlLCBtb2R1bGUpO1xuXG4gICAgICAgIHJldHVybiB7IGZhaWx1cmVzLCB2YWx1ZSB9XG4gICAgfVxuICAgIGVsc2V7XG4gICAgICAgIC8vY291bGRuJ3QgcGFyc2UsIHJldHVybiBwYXJzaW5nIGVycm9yc1xuICAgICAgICByZXR1cm4geyBmYWlsdXJlcywgdmFsdWU6IG51bGx9XG4gICAgfVxufTtcblxuZXhwb3J0IHtydW5uZXIsIFBhcnNlciwgVG9rZW5pemVyLCBDb21waWxlciwgTWVtb3J5TWFuYWdlciwgRHJhdywgRGF0ZXMsIFNJTVBMRV9JTVBPUlRTfVxuXG4iXSwibmFtZXMiOlsiVG9rZW5pemVyIiwiUGFyc2VyIiwiQ29tcGlsZXIiLCJjcmVhdGVNZW1vcnlNYW5hZ2VyIiwiTWVtb3J5TWFuYWdlciIsImNyZWF0ZURyYXdlciIsIkRyYXciLCJjcmVhdGVEYXRlIiwiRGF0ZXMiLCJTSU1QTEVfSU1QT1JUUyIsInJ1bm5lciIsInZhbHVlIiwib3V0cHV0RWxlbWVudCIsIm91dHB1dCIsImZhaWx1cmVzIiwicmVwcmVzZW50YXRpb24iLCJFTkNPREVSIiwiVGV4dEVuY29kZXIiLCJ0b2tlbml6ZXIiLCJwYXJzZXIiLCJjcmVhdGUiLCJwYXRoIiwiaW1wb3J0cyIsIm9uIiwiRVZFTlRfRkFJTCIsImZhaWx1cmUiLCJFVkVOVF9ET05FIiwiZGF0YSIsInBvc2l0aW9uIiwiYXJyYXkiLCJpbmRleCIsImxlbmd0aCIsImZlZWQiLCJlbmNvZGUiLCJkb25lIiwiZXhlY3V0ZSIsImdsdWUiLCJtb2R1bGUiLCJrZXkiLCJpS2V5IiwiT2JqZWN0IiwiZW50cmllcyIsInByb2NlZHVyZXMiLCJuYW1lIiwibWVtb3J5IiwiV2ViQXNzZW1ibHkiLCJNZW1vcnkiLCJpbml0aWFsIiwic3RhdGUiLCJkcmF3ZXIiLCJkYXRlcyIsImRlc2NyaXB0aW9uSW1wb3J0cyIsImZyZWV6ZSIsIm1lbW9yeUltcG9ydCIsImtleXMiLCJmb3JFYWNoIiwiaW1wb3J0S2V5IiwibW9kdWxlQ29tcGlsZWQiLCJjb21waWxlIiwibW9kdWxlSW5zdGFuY2UiLCJpbnN0YW50aWF0ZSIsInByb2NlZHVyZSIsImV4cG9ydHMiLCJwdXNoIiwibWVzc2FnZSIsInR5cGUiLCJpbm5lckhUTUwiLCJjb25zb2xlIiwibG9nIiwiZSIsImNvbXBpbGVyT3B0aW9ucyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/@munezero/floparser/index.js\n"));

/***/ })

});